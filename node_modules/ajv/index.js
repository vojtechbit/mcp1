function cloneSchema(schema) {
  if (Array.isArray(schema)) {
    return schema.map(cloneSchema);
  }
  if (schema && typeof schema === 'object') {
    const result = {};
    for (const [key, value] of Object.entries(schema)) {
      result[key] = cloneSchema(value);
    }
    return result;
  }
  return schema;
}

function addError(errors, instancePath, message) {
  errors.push({ instancePath, message });
}

function ensureArray(value) {
  if (Array.isArray(value)) {
    return value;
  }
  if (typeof value === 'undefined') {
    return null;
  }
  return [value];
}

function validateAgainstSchema(schema, data, errors, path) {
  if (!schema || typeof schema !== 'object') {
    return true;
  }

  if (Object.prototype.hasOwnProperty.call(schema, 'enum')) {
    const allowed = schema.enum;
    const isAllowed = allowed.some((option) => {
      if (typeof option === 'object' && option !== null) {
        try {
          return JSON.stringify(option) === JSON.stringify(data);
        } catch (error) {
          return false;
        }
      }
      return option === data;
    });
    if (!isAllowed) {
      addError(errors, path, `must be equal to one of the allowed values`);
      return false;
    }
  }

  const typeList = ensureArray(schema.type);
  if (typeList && typeList.length > 0) {
    const typeValid = typeList.some((typeName) => checkType(typeName, data));
    if (!typeValid) {
      addError(errors, path, `must be of type ${typeList.join(', ')}`);
      return false;
    }
  }

  if (typeList && typeList.includes('object') && data !== null && typeof data === 'object' && !Array.isArray(data)) {
    return validateObject(schema, data, errors, path);
  }

  if (typeList && typeList.includes('array') && Array.isArray(data)) {
    return validateArray(schema, data, errors, path);
  }

  return true;
}

function validateObject(schema, data, errors, path) {
  let valid = true;
  const required = Array.isArray(schema.required) ? schema.required : [];
  for (const key of required) {
    if (!Object.prototype.hasOwnProperty.call(data, key)) {
      addError(errors, `${path}/${key}`, 'is required');
      valid = false;
    }
  }

  const props = schema.properties && typeof schema.properties === 'object' ? schema.properties : {};
  const additional = Object.prototype.hasOwnProperty.call(schema, 'additionalProperties')
    ? schema.additionalProperties
    : true;

  for (const [key, value] of Object.entries(data)) {
    if (Object.prototype.hasOwnProperty.call(props, key)) {
      const childValid = validateAgainstSchema(props[key], value, errors, `${path}/${key}`);
      if (!childValid) {
        valid = false;
      }
    } else if (additional === false) {
      addError(errors, `${path}/${key}`, 'must NOT have additional properties');
      valid = false;
    } else if (additional && typeof additional === 'object') {
      const childValid = validateAgainstSchema(additional, value, errors, `${path}/${key}`);
      if (!childValid) {
        valid = false;
      }
    }
  }

  return valid;
}

function validateArray(schema, data, errors, path) {
  let valid = true;
  const itemsSchema = schema.items;
  if (Array.isArray(itemsSchema)) {
    for (let i = 0; i < itemsSchema.length; i += 1) {
      const childSchema = itemsSchema[i];
      const value = data[i];
      const childValid = validateAgainstSchema(childSchema, value, errors, `${path}/${i}`);
      if (!childValid) {
        valid = false;
      }
    }
  } else if (itemsSchema && typeof itemsSchema === 'object') {
    for (let i = 0; i < data.length; i += 1) {
      const childValid = validateAgainstSchema(itemsSchema, data[i], errors, `${path}/${i}`);
      if (!childValid) {
        valid = false;
      }
    }
  }
  return valid;
}

function checkType(typeName, value) {
  switch (typeName) {
    case 'array':
      return Array.isArray(value);
    case 'boolean':
      return typeof value === 'boolean';
    case 'integer':
      return Number.isInteger(value);
    case 'number':
      return typeof value === 'number' && Number.isFinite(value);
    case 'null':
      return value === null;
    case 'object':
      return value !== null && typeof value === 'object' && !Array.isArray(value);
    case 'string':
      return typeof value === 'string';
    case undefined:
      return true;
    default:
      return true;
  }
}

class Ajv {
  constructor(options = {}) {
    this.options = options;
  }

  compile(schema) {
    const cloned = cloneSchema(schema);
    const validator = (data) => {
      const errors = [];
      const valid = validateAgainstSchema(cloned, data, errors, '');
      validator.errors = errors.length > 0 ? errors : null;
      return valid;
    };
    validator.errors = null;
    return validator;
  }
}

export { Ajv };
export default Ajv;
